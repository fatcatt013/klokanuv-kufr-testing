# Generated by Django 4.0.3 on 2022-04-04 12:28

from django.db import migrations
import csv
import numpy as np
import os

# sheet1 csv file containing categories, tasks, subcategories
def base_list_sheet1():
    current_filepath = os.path.dirname(os.path.abspath(__file__))

    csv_filepath = "%s/csv/diagnostika_sheet1.csv" % current_filepath

    # read csv file and put it's contents into one list
    # serves as a baseline for information extraction
    with open(csv_filepath, 'r', encoding='utf-8') as file:
        data_reader = csv.reader(file, delimiter='|')
        data = []
        for entry in data_reader:
            data.append(entry)
    return data

# take base data and extract Category label from them
def populate_categories(base_data, Category):
    categories_unprocessed = []

    # iterate base_data and extract only 2nd position from each list (category)
    for row in base_data:
        categories_unprocessed.append(row[1])
    
    # make an numpy array out of those extracted categories and only keep unique categories
    categories_unique = np.unique(np.array(categories_unprocessed)).tolist()
    category_model_instances = []
    for cat_name in categories_unique:
        # create Category object instance, then append it to the list of all Category instances
        cat_model_inst = Category(label=cat_name)
        category_model_instances.append(cat_model_inst)

    # finally, create DB entries
    Category.objects.bulk_create(category_model_instances)


# take base data and extract Subcategory label + their respective parent_category from them
def populate_subcategories(base_data, Subcategory, Category):
    subcat_cat_unprocessed = []

    # iterate base_data and extract 2nd + 3rd position from each list and make list out of them
    # this way we get all matched pairs subcategory + category
    # then we use numpy to only keep unique values for each pair
    for row in base_data:
        subcat_cat_unprocessed.append([row[1], row[2]])

    # throw away duplicate pairs
    subcat_cat_unique = np.unique(np.array(subcat_cat_unprocessed), axis=0).tolist()

    subcategory_model_instances = []

    # separately extract subcat and cat, now parent category at 0th and subcategory at 1st index
    for subcat_match in subcat_cat_unique:
        # retrieve existing Category object to be able to pass it as parent_category
        parent_category = Category.objects.get(label=subcat_match[0])

        # create final  subcategory object instance and add it to a list
        subcat_model_inst = Subcategory(label=subcat_match[1], parent_category=parent_category)
        subcategory_model_instances.append(subcat_model_inst)

    # take the list of subcategory instances and create them in DB all at once
    Subcategory.objects.bulk_create(subcategory_model_instances)


# take base data and extract Subcategory label + their respective parent_category from them
def populate_tasks(base_data, Task, AssessmentType, Subcategory):
    # list of all combinations of category-subcategory-task
    task_subcat_cat = []

    for row in base_data:
        task_subcat_cat.append([row[0], row[1], row[2]])

    task_model_instances = []
    
    # TODO since we don't have assessment_type data yet, we need to create this dummy to proceed with other code
    dummy_assessment_type = AssessmentType(label="Dummy")
    dummy_assessment_type.save()

    # separately extract subcat and cat, now parent category at 0th and subcategory at 1st index
    for task_match in task_subcat_cat:
        # retrieve existing Category object to be able to pass it as parent_category
        subcategory = Subcategory.objects.get(label=task_match[2])

        # create final Task object instance and add it to a list
        task_model_inst = Task(
            task_text=task_match[0],
            subcategory=subcategory,
            expected_age_from=9, # TODO adjust once data is complete
            expected_age_to=9, # TODO adjust once data is complete
            assessment_type=dummy_assessment_type, # TODO adjust once data is complete
        )

        task_model_instances.append(task_model_inst)

    # take the list of subcategory instances and create them in DB all at once
    Task.objects.bulk_create(task_model_instances)


def populate_database(apps, schema_editor):
    Category = apps.get_model('record_sheet', 'Category')
    Subcategory = apps.get_model('record_sheet', 'Subcategory')
    Task = apps.get_model('record_sheet', 'Task')  # TODO finish once we are able to fill Tasks (ass. type data)
    AssessmentType = apps.get_model('record_sheet', 'AssessmentType')
    base_data = base_list_sheet1()

    populate_categories(base_data, Category)
    populate_subcategories(base_data, Subcategory, Category)
    populate_tasks(base_data, Task, AssessmentType, Subcategory)


class Migration(migrations.Migration):

    dependencies = [
        ('record_sheet', '0002_alter_task_difficulty'),
    ]

    operations = [
        migrations.RunPython(populate_database),
    ]

